{"name":"ACL","tagline":"Manage permissions on Doctrine entities","body":"[![Build Status](https://travis-ci.org/myclabs/ACL.png?branch=master)](https://travis-ci.org/myclabs/ACL) [![Coverage Status](https://coveralls.io/repos/myclabs/ACL/badge.png)](https://coveralls.io/r/myclabs/ACL) [![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/myclabs/ACL/badges/quality-score.png?s=2997ec4cb570c1cfef520d541daac853527d173e)](https://scrutinizer-ci.com/g/myclabs/ACL/) [![Latest Stable Version](https://poser.pugx.org/myclabs/acl/v/stable.png)](https://packagist.org/packages/myclabs/acl) [![Total Downloads](https://poser.pugx.org/myclabs/acl/downloads.png)](https://packagist.org/packages/myclabs/acl) [![License](https://poser.pugx.org/myclabs/acl/license.png)](https://packagist.org/packages/myclabs/acl)\r\n\r\nMyCLabs ACL is a library that helps managing permissions on resources.\r\n\r\nVocabulary:\r\n\r\n- **Security identity**: the entity which will be granted some access (this is generally the user)\r\n- **Resource**: a *thing* to which we want to control the access\r\n- **Authorization**: allows a security identity (user) to do something on a resource\r\n- **Role**: a role gives authorizations to a user (e.g. an administrator, an article editor, a project owner, …)\r\n\r\nThere are 2 kinds of resources:\r\n\r\n- an entity (example: article #123)\r\n- all entities of a given type (example: all articles), which is represented by the classname of the entity\r\n\r\n## Overview\r\n\r\nYou give permissions to a user by adding it a role:\r\n\r\n```php\r\n$acl->grant($user, new ArticleEditorRole($user, $article));\r\n```\r\n\r\nYou remove permissions to a user by removing the role:\r\n\r\n```php\r\n$acl->unGrant($user, $role);\r\n```\r\n\r\nTest permissions:\r\n\r\n```php\r\n$acl->isAllowed($user, Actions::EDIT, $article);\r\n```\r\n\r\nYou can also filter your queries to get only the entities the user has access to:\r\n\r\n```php\r\n$qb = $entityManager->createQueryBuilder();\r\n$qb->select('article')->from('Model\\Article', 'article');\r\n\r\nACLQueryHelper::joinACL($qb, $user, Actions::EDIT);\r\n\r\n// This query will return only the articles the user can edit\r\n$articles = $qb->getQuery()->getResult();\r\n```\r\n\r\n### Features\r\n\r\n- stored in database (you don't need to handle persistence yourself)\r\n- extremely optimized:\r\n  - filters queries at database level (you don't load entities the user can't access)\r\n  - joins with only 1 extra table\r\n- authorization cascading/inheritance\r\n- authorizations are rebuildable: you can change what an \"ArticleEditor\" can do afterwards and just rebuild the ACL\r\n- supports your custom actions on top of standard actions like \"view\", \"edit\", \"delete\", …\r\n\r\n### Limitations\r\n\r\n- because of Doctrine limitations you need to flush your resources before giving or testing authorizations\r\n- backed up by the database: testing `isAllowed` means one call to the database\r\n\r\n## Usage\r\n\r\n### 1. Mark your entity as a resource\r\n\r\nLet's say you want to control the access to an entity named `Article`.\r\n\r\nYou need to have your entity implement the `EntityResource` interface:\r\n\r\n```php\r\nclass Article implements EntityResource\r\n{\r\n    // ...\r\n\r\n    public function getId()\r\n    {\r\n        return $this->id;\r\n    }\r\n}\r\n```\r\n\r\nYou can also add an association to the roles that apply on this resource.\r\nSuch association is very useful so that the roles (and their authorizations) are deleted in cascade\r\nwhen the resource is deleted:\r\n\r\n```php\r\nclass Article implements EntityResource\r\n{\r\n    // ...\r\n\r\n    /**\r\n     * @ORM\\OneToMany(targetEntity=\"ArticleEditorRole\", mappedBy=\"article\", cascade={\"remove\"})\r\n     */\r\n    protected $roles;\r\n\r\n    public function __construct()\r\n    {\r\n        $this->roles = new ArrayCollection();\r\n    }\r\n}\r\n```\r\n\r\nThis association can also be useful if you need to find all the \"editors\" of an article for example.\r\n\r\n### 2. Creating a new role\r\n\r\nThe role gives the authorizations.\r\n\r\nTo create a new role, extend the `Role` abstract class:\r\n\r\n```php\r\n/**\r\n * @Entity(readOnly=true)\r\n */\r\nclass ArticleEditorRole extends Role\r\n{\r\n    /**\r\n     * @ManyToOne(targetEntity=\"Article\", inversedBy=\"roles\")\r\n     */\r\n    protected $article;\r\n\r\n    public function __construct(User $user, Article $article)\r\n    {\r\n        $this->article = $article;\r\n\r\n        parent::__construct($user);\r\n    }\r\n\r\n    public function createAuthorizations(ACL $acl)\r\n    {\r\n        $acl->allow(\r\n            $this,\r\n            new Actions([Actions::VIEW, Actions::EDIT]),\r\n            $this->article\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nThe authorizations given by the role are created in the `createAuthorizations()` method.\r\n\r\nFor creating an authorization, you need to call `$acl->allow()` with:\r\n\r\n- the role (which will also provide the user/security identity that is being given access)\r\n- the actions that are included in the authorization\r\n- the resource\r\n\r\nThe resource can be either an entity instance (as shown above) or an entity classname, which will\r\ngive access to all entities of that type:\r\n\r\n```php\r\n// This will allow the users having the role to be able to view ALL the articles\r\n$acl->allow(\r\n    $this,\r\n    new Actions([Actions::VIEW]),\r\n    new ClassResource('My\\Model\\Article')\r\n);\r\n```\r\n\r\n### Actions\r\n\r\nAs you have seen in the previous examples, you can allow and test several actions on a resource.\r\n\r\n- `allow`\r\n\r\nWhen allowing access, you can allow the user to do several actions like so:\r\n\r\n```php\r\n$actions = new Actions();\r\n$actions->view = true;\r\n$actions->edit = true;\r\n\r\n$acl->allow($role, $actions, $resource);\r\n```\r\n\r\nThe way shown in the examples above is a shortcut, sometimes more practical:\r\n\r\n```php\r\n$actions = new Actions([\r\n    Actions::VIEW,\r\n    Actions::EDIT,\r\n]);\r\n\r\necho $actions->view; // true\r\necho $actions->delete; // false\r\n```\r\n\r\n- `isAllowed`\r\n\r\nWhen testing access, you can only test for one action:\r\n\r\n```php\r\n$acl->isAllowed($user, Actions::EDIT, $resource);\r\n```\r\n\r\nHere is the list of all actions natively supported:\r\n\r\n```php\r\nclass Actions\r\n{\r\n    const VIEW = 'view';\r\n    const CREATE = 'create';\r\n    const EDIT = 'edit';\r\n    const DELETE = 'delete';\r\n    const UNDELETE = 'undelete';\r\n    const ALLOW = 'allow';\r\n\r\n    public $view = false;\r\n    public $create = false;\r\n    public $edit = false;\r\n    public $delete = false;\r\n    public $undelete = false;\r\n    public $allow = false;\r\n\r\n    // ....\r\n}\r\n```\r\n\r\nYou don't have to use them all if you don't need it.\r\n\r\nFYI, `ALLOW` means \"the user is allowed to allow other users on this resource\", i.e. it's the action\r\nof managing access on the resource. This is usually what an administrator does: he can configure the\r\naccesses on the resources he administrates.\r\n\r\n\r\n## Setup\r\n\r\nYou first need to register the annotation mapping to your Doctrine metadata driver.\r\n\r\nCreating the ACL is simple:\r\n\r\n```php\r\n$acl = new ACL($entityManager);\r\n```\r\n\r\nHowever, you must register some listener on the entity manager:\r\n\r\n```php\r\n$aclSetup = new \\MyCLabs\\ACL\\Doctrine\\ACLSetup();\r\n// Set which class implements the SecurityIdentityInterface (must be called once)\r\n$aclSetup->setSecurityIdentityClass('My\\Model\\User')\r\n// Register role classes\r\n$aclSetup->registerRoleClass('My\\Model\\ArticleEditorRole', 'articleEditor');\r\n\r\n// To avoid instantiating the ACL uselessly (and avoid a circular dependency),\r\n// we must use a \"locator\" callback\r\n$aclLocator = function () {\r\n    return $container->get('MyCLabs\\ACL\\ACL');\r\n};\r\n\r\n// Apply the configuration to the entity manager\r\n$aclSetup->setUpEntityManager($entityManager, $aclLocator);\r\n```\r\n\r\n## Authorization cascading\r\n\r\nThere are 2 ways to cascade authorizations:\r\n\r\n- via a hierarchy of resource: parent resources cascade their authorizations to sub-resources\r\n- via a custom cascading strategy (if you have exotic needs)\r\n\r\nThe first solution is supported out of the box. Example: allowing a user to access a folder and all its sub-folders.\r\n\r\nYou have 2 solutions to define the hierarchical structure:\r\n\r\n- implementing the `CascadingResource` interface\r\n- writing a `ResourceGraphTraverser`\r\n\r\n### CascadingResource\r\n\r\nThis is a very simple solution, yet a bit limited, and it crowds your entity a bit.\r\n\r\nExample:\r\n\r\n```php\r\nclass Category implements EntityResource, CascadingResource\r\n{\r\n    /**\r\n     * @var Category[] Sub-categories\r\n     **/\r\n    private $children;\r\n\r\n    /**\r\n     * @var Category|null Parent category\r\n     **/\r\n    private $parent;\r\n\r\n    // ...\r\n\r\n    public function getParentResources(EntityManager $entityManager)\r\n    {\r\n        $parents = [ new ClassResource(get_class()) ];\r\n\r\n        if ($this->parent !== null) {\r\n            $parents[] = $this->parent;\r\n        }\r\n\r\n        return $parents;\r\n    }\r\n\r\n    public function getSubResources(EntityManager $entityManager)\r\n    {\r\n        return $this->children->toArray();\r\n    }\r\n}\r\n```\r\n\r\nNote: if you want to give authorizations on the class-resource \"All categories\" (`new ClassResource('Category')`)\r\ndon't forget to return it in `getParentResources()` (as shown above). Else you can ignore it.\r\n\r\nJust so you know, `ClassResource` implements the `CascadingResource` interface:\r\n\r\n```php\r\nfinal class ClassResource implements ResourceInterface, CascadingResource\r\n{\r\n    // ...\r\n\r\n    public function getSubResources(EntityManager $entityManager)\r\n    {\r\n        $repository = $entityManager->getRepository($this->class);\r\n\r\n        return $repository->findAll();\r\n    }\r\n}\r\n```\r\n\r\n**Important**: with `CascadingResource`, MyCLabs\\ACL will assume each resource only returns its direct\r\nchildren/parent resources. So they will be traversed recursively, which sometimes can be inefficient.\r\nHave a look below for an alternative solution.\r\n\r\n### ResourceGraphTraverser\r\n\r\nThe `ResourceGraphTraverser` is an object you write that must return the parent and sub-resources of a resource.\r\n\r\nAs explained, it must return **all** the sub/parent resources, which avoids MyCLabs\\ACL\r\nrecursively looking for sub/parent resources.\r\n\r\nExample:\r\n\r\n```php\r\nclass FolderResourceGraphTraverser implements ResourceGraphTraverser\r\n{\r\n    public function getAllParentResources(ResourceInterface $resource)\r\n    {\r\n        if (! $resource instanceof Folder) {\r\n            throw new \\RuntimeException;\r\n        }\r\n\r\n        $parents = $resource->getAllParentFoldersRecursively();\r\n        $parents[] = new ClassResource(Folder::class);\r\n\r\n        return $parents;\r\n    }\r\n\r\n    public function getAllSubResources(ResourceInterface $resource)\r\n    {\r\n        if (! $resource instanceof Folder) {\r\n            throw new \\RuntimeException;\r\n        }\r\n\r\n        return array_merge(\r\n            $resource->getAllSubFoldersRecursively(),\r\n            $resource->getAllFiles()\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nTo register it:\r\n\r\n```php\r\n$cascadeStrategy = new SimpleCascadeStrategy($entityManager);\r\n$cascadeStrategy->setResourceGraphTraverser(\r\n    Folder::class,\r\n    $c->get(FolderResourceGraphTraverser::class)\r\n);\r\n\r\n$acl = new ACL($em, $cascadeStrategy);\r\n```\r\n\r\n## Custom actions\r\n\r\nThe default actions that you can use are:\r\n\r\n- view\r\n- edit\r\n- delete\r\n- undelete\r\n- allow (= manage permissions on the resource)\r\n- create\r\n\r\nYou can add your own actions by overriding the `Actions` class:\r\n\r\n```php\r\nnamespace My\\Model;\r\n\r\nuse Doctrine\\ORM\\Mapping as ORM;\r\nuse MyCLabs\\ACL\\Model\\Actions as BaseActions;\r\n\r\n/**\r\n * @ORM\\Embeddable\r\n */\r\nclass Actions extends BaseActions\r\n{\r\n    const PUBLISH = 'publish';\r\n\r\n    /**\r\n     * @ORM\\Column(type = \"boolean\")\r\n     */\r\n    public $publish = false;\r\n\r\n    /**\r\n     * {@inheritdoc}\r\n     */\r\n    public static function all()\r\n    {\r\n        return new static([\r\n            static::VIEW,\r\n            static::CREATE,\r\n            static::EDIT,\r\n            static::DELETE,\r\n            static::UNDELETE,\r\n            static::ALLOW,\r\n            static::PUBLISH,\r\n        ]);\r\n    }\r\n}\r\n```\r\n\r\nHere we added a \"publish\" action to restrict who can publish articles.\r\n\r\nNow we need to configure MyCLabs\\ACL to use this class instead of the base class:\r\n\r\n```php\r\n$aclSetup->setActionsClass('My\\Model\\Actions');\r\n```\r\n\r\n## Performances\r\n\r\nFor better performances, you can follow the following advices:\r\n\r\n- Cache calls to `isAllowed()`: every time you call that method, it will issue a query to the database.\r\n\r\nYou shouldn't call `isAllowed()` a lot, if you do try instead to filter your queries using the ACL (see above),\r\nthis is much more efficient. However, if you do, you might want to cache the results of those calls in order\r\nto avoid doing too many queries.\r\n\r\nMyCLabs\\ACL doesn't ship with a cache for now because there are some problems associated to it, mainly\r\ncache invalidation when ACLs changes. However this can change, you are free to file an issue for this.\r\n\r\nBe aware that using a cache for this is not mandatory. If your application doesn't handle a lot of traffic\r\nthe ACL system will work just fine (the isAllowed query is very simple and optimized).\r\n\r\n- Roles should be set as \"Read Only\" for Doctrine so that they are not tracked for changes uselessly\r\n\r\nThis is minor, but why not.\r\nThis is not a hard requirement though, if your roles can change, you are free to ignore this.\r\n\r\nExample with annotations:\r\n\r\n```php\r\n/**\r\n * @Entity(readOnly=true)\r\n */\r\nclass ArticleEditorRole extends Role\r\n{\r\n}\r\n```\r\n\r\nOr with YAML:\r\n\r\n```yaml\r\nNamespace\\ArticleEditorRole:\r\n  type: entity\r\n  readOnly: true\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}